#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

//野指针指的是指针指向的位置是不可知的（随机的，不正确的，没有明确限制的）

//野指针成因

////1指针未初始化
//int main()
//{
//	int* p;
//	//p未初始化，一个局部变量未初始化，那么他的值将会是随机的，所以p指针的位置是随机的
//	*p = 10;//这时解引用就会非法访问内存
//	//如果不知道该给让指针指向什么，那么初始化的时候可以先给他一个空指针（NULL）
//	int* q = NULL;//就跟初始化变量时赋0一样（int a = 0;）
//	return 0;
//}


////2指针越界访问
//int main()
//{
//	int arr[5] = { 0 };
//	int* p = arr;
//	int i = 0;
//	for (i = 0; i <= 5; i++)//当循环到第六次的时候，数组中的空间都已经被访问过了，这时p指向的空间就已经超出这个数组了，这时p就是越界访问了，p变成野指针
//	{
//		(*p) = i;
//		p++;
//	}
//	return 0;
//
//}



////3指针指向的空间释放
//int* test()
//{
//	int a = 10;
//	return &a;
//}//函数返回a的地址
//
//int main()
//{
//	int* p = test();//p接收a的地址
//	//a是个局部变量，当退出这个函数时，局部变量就会销毁，虽然p还存着他的地址，但是这个地址里存在的内容已经被销毁了，所以通过p是无法访问这个地址的
//	return 0;
//}



////尽可能避免野指针的方法
//int main()
//{
//	//每次创建指针时，明确的给他进行初始化
//	int a = 0;
//	int* pa = &a;
//
//	//但是如果创建指针时还不知道要给指针初始化什么地址，那么可以先给他赋个空指针（NULL）
//	int* p2 = NULL;
//	//但是这样初始化的话，在给他指向一个目前的地址前，不能解引用这个指针
//	//*p2 = 10;//err
//	//那么我们在使用指针前可以加个保险
//	if (p2 != NULL)
//	{
//		*p2 = 10;
//	}//这样做的话，只要没给指针明确的地址，那么就无法解引用指针，可以避免程序因此崩溃
//	//但这其实不是百分百可行的
//	return 0;
//}

int* test()
{
	int a = 10;
	return &a;
}

int main()
{
	int* p = test();
	//printf("%d\n", *p);//这时会发现依旧打印出了10
	//不是说地址里的内存已经被销毁了吗，为什么能打印出对应的值呢
	//这时因为退出函数后，a本来占的空间被让了出来，里面的存的东西暂时是不会变的，直到有其他函数调用了，影响到了这个空间，把里面的值进行了修改
	//比如说现在再打印一次*p的值
	//printf("%d\n", *p);//得到13572399
	//或者随便写点程序给他造成一些影响
	printf("assa\n");
	printf("%d\n", *p);//得到5
	return 0;
}


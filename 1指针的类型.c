#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

////指针类型的第一个意义
////1指针变量的类型决定了在解引用该指针时，访问多少个字节
////解引用char* 类型的指针时，访问1个字节
////解引用int* 类型的指针时，访问4个字节
////解引用double* 类型的指针时，访问8个字节
//int main()
//{
//	int a = 0x11223344;//0x开头代表是16进制
//	//十六进制必须是八位数，对应32位的二进制，即32个bit(4个字节的int)
//	//十六进制由15个数组成
//	//0 1 2   3   4 5 6     7 8 9 a     b c d e f
//	//0 1 10  11      110         1010          1111
//	//十六进制的最大数也都在二进制的四位数的范围内，所以每个十六进制数都将占4个二进制数位
//
//	//int* pa = &a;//通过指针变量存下地址
//	//*pa = 0;//通过解引用指针修改地址对应的变量
//	//已知所有指针变量的大小都是4个字节（x86）/8个字节（x64）
//	//那么为什么建立指针变量时要区分指针的类型呢
//
//	//如果使用不对应的指针类型来存放变量的地址会怎么样呢
//	char* pc = &a;
//	*pc = 0;//调试后发现，原本存的值显示44 33 22 11
//			//结果解引用pc后变为了	 00 33 22 11
//			//如果用int*来存地址并解引用的话结果应该为00 00 00 00
//	//由此，我们发现
//	//指针的类型决定了解引用指针时，访问几个字节
//	//int a 这个本来占了4个字节，而解引用char* pc这个指针时只会访问1个字节，所以最后只修改了一个字节的内容
//	//如果用double*的话，那么就会访问8个字节，可能会影响到其他存储的内容
//	int arr[2] = { 1,2 };//已知数组里的元素会被存储在相邻的空间里
//	//int* ar = &arr;    //那么用int*的指针来存储数组的地址时，本质上存储的只是数组首元素地址，解引用这个指针时，只会访问4个字节，即只改变首元素的值
//	double* ar = &arr;	 //但是如果用double*的指针来存储地址时，虽然存的也是首元素地址，但是解引用该地址时，因为会访问8个字节，所以不仅改变了首元素的值，
//						 //还改变了他后面的第二个元素的值
//	*ar = 0;
//
//
//	printf("%d\n", arr[0]);
//	printf("%d\n", arr[1]);
//
//	return 0;
//}


////指针类型的第二个意义
////2类型决定了解引用后要跳过几个字节的地址
////指针在+-1时，根据指针的类型决定要跳过几个字节
////
//int main()
//{
//	int a = 0x11223344;
//	int* pi = &a;
//	char* pc = (char*)&a;
//
//	printf("%p\n", pi);//004FFE50
//	printf("%p\n", pc);//004FFE50
//	//可以发现，不管用什么类型的指针来存放地址，存放的内容都一样
//
//	printf("%p\n", pi + 1);//004FFE54
//	printf("%p\n", pc + 1);//004FFE51
//	//但是当两个指针都+1时，跳过的字节数量却不一样
//	//这是因为，整型变量（int）创建时，其实是分配了4个字节的空间的，但是地址其实只能表示一个字节所对应的空间
//	//所以a变量创建时其实有四个字节的空间分别存放11 22 33 44
//	//而004FFE54这个地址其实只对应了第一个字节的空间，即11对应的空间
//	//所以访问int类型对应的地址时，每次必须访问4个字节
//	//而char类型对应的地址，只需要访问1个字节
//		
//
//	return 0;
//}



//对于相同大小的不同类型的指针类型比如（int和float）
int main()
{
	int a = 0x11223344;
	int* pi = &a;
	float* pf = &a;
	//两者访问地址时都会访问4个字节，那么是否代表两者完全相同呢

	//*pi = 100;//64 00 00 00
	*pf = 100;//00 00 c8 42
	//调试后发现，解引用指针后，两者的对变量的修改有不同的效果
	//原来指针变量的类型也决定了解引用指针时，会以什么方法存储数据
	//当解引用int*类型的指针时，他就会以int的方式存储数据
	//解引用float*类型的指针时，则会以flaot的方式存储数据


	return;
}